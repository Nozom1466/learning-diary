[Problems](https://leetcode.cn/discuss/post/3578981/ti-dan-hua-dong-chuang-kou-ding-chang-bu-rzz7/)

1. 固定窗口大小

一个循环，right element in -> update target -> left element out

[643](https://leetcode.cn/problems/maximum-average-subarray-i/description/)
```python
class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        """
        Args:
            nums: given array
            k: fixed window size
        """ 
        ans = -float('inf')
        cur_sum = 0  # init target

        for i in range(len(nums)):
            cur_sum += nums[i]  # element in
            
            if i - k + 1 >= 0:
                ans = max(ans, cur_sum / k)  # update
                cur_sum -= nums[i - k + 1]  # element out
        return ans
```
> 注意当 `k = 0`，window 长度为 0 时，左边界 `i - k + 1` 在算最后一步的时候会超过 `len(nums) - 1`，所以需要提前判断剔除 [1423](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)


2. 不定长-越短越合法/求最长/最大

右端点在 for loop 里循环，不满足条件时，左端点跟上，直到满足条件了，更新

[1493](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/)
```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        
        ans = l = 0
        num_zero = 0

        for r in range(len(nums)):
            num_zero += not nums[r]  # right ele 

            while num_zero > 1:  # until window turns valid
                num_zero -= not nums[l]
                l += 1
            
            ans = max(ans, r - l)  # update
        return ans
```
> while 条件稍微 tricky


3. 越长越合法/求最短/最小
4. 求子数组个数-越短越合法

这种就是某个子数组里边的所有子数组都满足要求的条件。我们不能直接统计全部子数组，因为会和后边计算过程重复。关键就是如果右端点 $r$ 往右边移动了 1 位，到达 $r + 1$，那么对于给定的左端点，子数组的个数会增加多少。增加 $r - l + 1$ 个子数组。

[713](https://leetcode.cn/problems/subarray-product-less-than-k/description/)

```python
class Solution:

    def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
        if k <= 1:
            return 0
            
        ans_cnt = 0
        l = max_len = 0
        cur_prod = 1
        
        for r in range(len(nums)):
            cur_prod *= nums[r]
            while cur_prod >= k:
                cur_prod /= nums[l]
                l += 1
            ans_cnt += r - l + 1
            
        return ans_cnt
```

5. 越长越合法

这种就是至少 XXX 个元素满足 XXX，其实是让你先找到最短的不满足条件的数组，然后当前的左端点左边的每个元素作为子数组左端点，形成的子数组，都是满足条件的。所以关键就是对于给定的 $r$ , 左端点 $l$ 是第一个不满足所给条件的，那么 $0, 1, \dots l - 1$ 做为子数组的左端点形成的 $[0, r], [1, r], \dots, [l - 1, r]$ 都是满足条件的。一共有 $l$ 个，所以就是 `ans += l`.

[1358](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/description/)

```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        ans = l = 0
        freq = defaultdict(int)

        for r in range(len(s)):
            freq[s[r]] += 1

            while len(freq) == 3:
                freq[s[l]] -= 1
                if freq[s[l]] == 0:
                    del freq[s[l]]
                l += 1
            ans += l
        
        return ans
```

