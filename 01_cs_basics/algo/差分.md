
跟前缀和是类似于积分与求导关系，差分是求当前元素减去前边所有元素的和，第一个元素就是 `a` 中的第一个元素：

```python
a = [a0, a1, a2, ..., an]
diff[i] = ai - ai_1 - ... - a0
```

还原到原来的数组只要求前缀和就ok了：

```python
list(accumulate(diff))
```

目前理解是主要用在对子数组的批量操作上。比如说我想对 `[i, j]` 区间上的所有元素都 +1，反映到差分数组 `diff` 上就是：

```python
diff[i] += 1
diff[j] -= 1
```

这里 `diff[i] += 1` 相当于在原数组 `a` 中对 `i` 以后的数字都 +1，因为后边的位置想要还原成 `a` 的时候，需要加前边的 `a[i]` ，所以`a` 中对 `i` 以后的数字都 +1。同理 `a[j]` 后边的数字就都 -1。二者效果叠加到一起，就剩下中间 `a[i]` 到 `a[j]` 的数字 +1 了。图示：

![差分](https://pic.leetcode.cn/1747885435-uDDcwT-lc1094-c.png)


注意开数组的时候要多开一格：

```python
diff = [0 for _ in range(n + 1)]
diff = [0] * (n + 2)

for l, r in nums:
	diff[l - 1] += 1
	diff[r] -= 1
```



常见错误【老G】：

|错误类型|原因|正确做法|示例|
|---|---|---|---|
|**① 长度不足**|未多开一位导致 `r+1` 越界|`diff = [0] * (n + 1)`|✅|
|**② 区间定义错误**|`[l, r)` / `[l, r]` 混淆|闭区间 `[l, r]` 用 `r+1`，半开区间 `[l, r)` 用 `r`|`python\n# 半开区间 [l, r)\ndiff[l]+=val; diff[r]-=val\n`|
|**③ 错误偏移**|使用 `l-1` 导致负下标|保持索引与原数组一致|`python\ndiff[l] += 1 # ✅\n`|
|**④ 忘记还原**|未累加得到原数组|使用 `accumulate(diff)`|✅|
|**⑤ 映射错误**|年份或坐标未基准化|固定基准：`idx = year - base`|`python\nBASE=1950\ndiff[birth-BASE]+=1; diff[death-BASE]-=1\n`|

定义与初始化【老G】:

```python
diff = [0 for _ in range(n + 2)]  # 一个开头，一个结尾
```

区间修改【老G】：

```python
diff[l] += val
diff[r + 1] -= val  # for [l, r]
diff[r] -= val # for [l, r)
```

还原【老G】：

```python
arr = list(accumulate(diff))
```




1. 基础用法

[1094](https://leetcode.cn/problems/car-pooling/description/)
```python
class Solution:
    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:
        diff = [0 for _ in range(1001)]
        diff[0] = 0

        for num_pass, fr, to in trips:
            diff[fr] += num_pass
            diff[to] -= num_pass
        
        summer = 0
        for i in range(len(diff)):
            summer += diff[i]
            if summer > capacity:
                return False
        
        return True
```


2. 扫描线

[3453](https://leetcode.cn/problems/separate-squares-i/description/)
```python
class Solution:
    def separateSquares(self, squares: List[List[int]]) -> float:
        diff = defaultdict(int)  # 10e9 爆 mem 了
        total_area = 0

        for x, y, l in squares:
            total_area += l * l
            diff[y] += l    
            diff[y + l] -= l 
        
        sum_l = sum_area = 0
        for yl, yh in pairwise(sorted(diff)):
            sum_l += diff[yl]
            sum_area += sum_l * (yh - yl)
            if sum_area * 2 >= total_area:
                return yh - (sum_area - total_area * 0.5) / sum_l
```

arr记录的是正方形的高度。这里还有一点：我们可以用哈希表代替数组形式的差分，因为我们可以通过


3. 二维差分

类似，就是修改横向的下一个，修改纵向的下一个，修改斜对角的下一个

![二维差分](https://pic.leetcode.cn/1702439895-HZofag-LC2132-c.png)


[2536](https://leetcode.cn/problems/stamping-the-grid/solutions/1199642/wu-nao-zuo-fa-er-wei-qian-zhui-he-er-wei-zwiu/)
```python
class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        diff = [[0] * (n + 2) for _ in range(n + 2)]

        for r1, c1, r2, c2 in queries:
            diff[r1 + 1][c1 + 1] += 1
            diff[r1 + 1][c2 + 2] -= 1
            diff[r2 + 2][c1 + 1] -= 1
            diff[r2 + 2][c2 + 2] += 1
        
        for i in range(1, n + 1):
            for j in range(1, n + 1):
                diff[i][j] += diff[i][j - 1] + diff[i - 1][j] - diff[i - 1][j - 1]
        
        diff = diff[1:-1]
        for i, row in enumerate(diff):
            diff[i] = row[1:-1]
        return diff
```