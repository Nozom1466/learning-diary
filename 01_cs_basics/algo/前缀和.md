
1. 基础

前缀和记得前边有个 `0`，不要忘记这个0对于：1.下标 2.哈希表记录 的影响。前缀和可以用以下方式一行实现：

```python
presum = list(accumulate(nums, initial=0))
```

对于计算 `[l, r]` 的和，要注意下标问题。实际上下标是从元素 `0` 开始算起：

```python
sub_sum = presum[r + 1] - presum[l]
```


2. 前缀和与哈希表

与遍历结合，两个变量遍历，用哈希表维护左边。这里涉及到子数组的内容需要与滑动窗口的内容做个区分：当数组里边有负数时，我们应该考虑用前缀和，全是非负数时用哈希表。因为有负数的时候，维护左指针向右移动，并不能维持目标值增减的单调性。

[930](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

```python
class Solution:
    def numSubarraysWithSum(self, nums: List[int], goal: int) -> int:
        """solve(k) - solve(k - 1)"""

        return self.solve(nums, goal) - self.solve(nums, goal - 1)
    
    def solve(self, nums: List[int], k: int):
        cur_sum = l = ans = 0

        for r in range(len(nums)):
            cur_sum += nums[r]

            while cur_sum > k and l <= r:
                cur_sum -= nums[l]
                l += 1
            
            ans += r - l + 1
        return ans
```


3. 距离前缀和

这类题有个小特征：求绝对值之差的和。首先我们需要将数组排序，之后可以将绝对值之和转换成面积问题，再利用前缀和进行优化即可。计算时先算左边的面积：用 `nums[i] * i - presum[i]`， 右边就是 `presum[-1] - presum[i] - nums[i] * (len(nums) - i)`.  位置的寻找可以使用二分。具体就是：

![距离前缀和](https://pic.leetcode.cn/1679808210-FVsAou-t3.png)

[1685](https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/description/)
```python
class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        presum = list(accumulate(nums, initial=0))

        ans = []
        for i, num in enumerate(nums):
            left = i * num - presum[i]
            right = presum[-1] - presum[i] - num * (len(nums) - i)
            ans.append(left + right)
        return ans
```