
> Debug 先看你有没有初始化！

1. 基础

前缀和记得前边有个 `0`，不要忘记这个0对于：1.下标 2.哈希表记录 的影响。前缀和可以用以下方式一行实现：

```python
presum = list(accumulate(nums, initial=0))
```

> 有时候得看具体情况再初始化，这里的和是 0，有些记录位置的题目比如 [1371](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/description/),初始化变成 -1, 因为计算的是子数组的长度


对于计算 `[l, r]` 的和，要注意下标问题。实际上下标是从元素 `0` 开始算起：

```python
sub_sum = presum[r + 1] - presum[l]
```


2. 前缀和与哈希表

与遍历结合，两个变量遍历，用哈希表维护左边。这里涉及到子数组的内容需要与滑动窗口的内容做个区分：当数组里边有负数时，我们应该考虑用前缀和，全是非负数时用哈希表。因为有负数的时候，维护左指针向右移动，并不能维持目标值增减的单调性。

[560](https://leetcode.cn/problems/subarray-sum-equals-k/)

```python
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        presum = 0
        ans = 0
        
        # find presum[l] = presum[r] - k: how many l is legal?
        freq = defaultdict(int)
        freq[0] = 1  # presum position 0
        
        # keep presum while checking
        for r in range(len(nums)):
            presum += nums[r]
            ans += freq[presum - k]
            freq[presum] += 1
            
        return ans        
```

哈希表可以记录什么？
- 某状态出现的频率，比如某值出现的频率，在求子数组的和=k的时候：[560](https://leetcode.cn/problems/subarray-sum-equals-k/)
- 某状态出现的位置，比如某值出现的最早的位置，在求最长满足某条件的子数组的时候：[1371](https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/)



3. 距离前缀和

这类题有个小特征：求绝对值之差的和。首先我们需要将数组排序，之后可以将绝对值之和转换成面积问题，再利用前缀和进行优化即可。计算时先算左边的面积：用 `nums[i] * i - presum[i]`， 右边就是 `presum[-1] - presum[i] - nums[i] * (len(nums) - i)`.  位置的寻找可以使用二分。具体就是：

![距离前缀和](https://pic.leetcode.cn/1679808210-FVsAou-t3.png)

[1685](https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/description/)
```python
class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        presum = list(accumulate(nums, initial=0))

        ans = []
        for i, num in enumerate(nums):
            left = i * num - presum[i]
            right = presum[-1] - presum[i] - num * (len(nums) - i)
            ans.append(left + right)
        return ans
```


4. 异或和前缀和

这里的异或和主要用于替代哈希表，对于记录某字母出现的次数是奇数还是偶数的问题，我们原本可以用哈希表记录 `[0, i]` 期间积累的的状态：

```python
freq_i = {
	'a': 2,
	'b': 1,
	...
}
```

然后再用后边的 freq 减去前边的 freq，得到子数组的 freq，再查看奇偶。但是其实 `freq_i` 可以被压缩成：`status = 0b000...10` (26位)，其中每一位代表了积累到当前位置，某数字的个数是奇数还是偶数。所形成的 `presum = [status_1, status_2, ...]` 也就压缩了每一个位置的一批字母个数奇偶信息。在每次更新时，我们可以直接用 `status ^= 1 << (ord(letter) - ord('a'))` 进行更新（非字母的看具体情况计算）；在考察子数组性质的时候，可以直接使用异或操作计算子数组的字母个数奇偶情况：`(status_1 ^ status_2).bit_count()` 考察子数组中字母个数为奇数的字母有多少个。

> 所以再 general 一点，就是用二进制压缩统计变量，二进制代表了：每个 bit 代表的元素有两种状态，比如奇数和偶数，并且是互相转换的。（那这是否可以扩展成 n 进制？代表 n 个状态）

[1177](https://leetcode.cn/problems/can-make-palindrome-from-substring/description/)
```python
class Solution:
    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:
        
        # 00 ... 000 -> 26 bits for parity of frequency for 26 lower letters
        presum = [0]
        for letter in s:
            presum.append(presum[-1] ^ (1 << (ord(letter) - ord('a'))))
        
        ans = []
        for q in queries:
            l, r, k = q
            illegal = (presum[r + 1] ^ presum[l]).bit_count()
            ans.append(illegal - ((r - l + 1) & 1) <= k * 2)
        return ans
        
```
