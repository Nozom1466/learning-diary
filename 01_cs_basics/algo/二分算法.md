1. 二分查找

[ref](https://leetcode.cn/problems/binary-search/description/)
关键就是区间不变量的选择，有四种选法：`(), (], [), []`，每种更新都不太一样，一共四种写法。首先需要明确一点：`nums[mid] != target` 的时候，`nums[mid]` 并不是答案，`target` 或者比 `nums[mid]` 大，或者比 `nums[mid]` 小。 

- 对于`()`，`nums[mid] < target`，说明 `target` 在右边，`l` 要更新成 `mid` 相关的，因为左边是开，所以本来 `nums[mid]` 就取不到，所以更新 `l = mid`。同理右侧 `r = mid`。初始值 `l, r = -1, len(nums)`，保证区间有值，`while` 取 `l + 1 < r`
```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = -1, len(nums)

        while l + 1 < r:  #  ()
            mid = (l + r) // 2

            if nums[mid] < target:
                l = mid
            elif nums[mid] > target:
                r = mid
            else:
                return mid 
            
        return -1
```

- 对于`[]`，`nums[mid] < target`，说明 `target` 在右边，`l` 要更新成 `mid` 相关的，因为左边是闭区间，所以 `nums[mid]` 可能取到，但是 `nums[mid]` 又肯定不是答案，所以更新 `l = mid + 1`，这样区间内取到 `nums[mid + 1]` 就有可能是答案了。右侧 `r = mid - 1`。初始值 `l, r = 0, len(nums) - 1`。保证区间有值，`while` 取 `l <= r`。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1

        while l <= r:  #  []
            mid = (l + r) // 2

            if nums[mid] < target:
                l = mid + 1
            elif nums[mid] > target:
                r = mid - 1
            else:
                return mid 
            
        return -1
```

- 对于`[)`，`nums[mid] < target`，说明 `target` 在右边，`l` 要更新成 `mid` 相关的，因为左边是闭区间，所以 `nums[mid]` 可能取到，但是 `nums[mid]` 又肯定不是答案，所以更新 `l = mid + 1`，这样取到 `nums[mid + 1]` 就有可能是答案了。右侧 `r = mid`，本来就取不到。初始值 `l, r = 0, len(nums)`。保证区间有值，`while` 取 `l < r`。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:  #  [)
            mid = (l + r) // 2

            if nums[mid] < target:
                l = mid + 1
            elif nums[mid] > target:
                r = mid
            else:
                return mid 
            
        return -1
```


- 对于 `(]`，相似的分析，但是需要注意一点：因为 `(l + r) // 2` 是向下取整的，这会导致 `(]` 在最后两个元素更新 `l` 的时候， `l` 停留在左边不变，这时候我们可以变化一下 `mid` 的计算，变成 `mid = (l + r) // 2 + 1`，这样在最后的时候就可以正确更新下标了。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = -1, len(nums) - 1

        while l < r:  #  (]
            mid = (l + r) // 2 + 1

            if nums[mid] < target:
                l = mid
            elif nums[mid] > target:
                r = mid - 1
            else:
                return mid 
            
        return -1
```


2. 二分找边界

其实就是让他即使 `nums[mid] == target` 了，指针继续移动，直到指针收敛到指定位置，拿到下标

[35](https://leetcode.cn/problems/search-insert-position/)

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)

        while l < r:
            mid = (l + r) >> 1

            if nums[mid] < target:
                l = mid + 1
            elif nums[mid] >= target:  # 这里即使相等也左移右端点，最后收敛到的就是第一个 >= target 的位置
                r = mid
        
        return l
```


3. 二分答案

主要就是找到二分的东西是什么，可以找 $f(\cdot)$ 来将当前数组映射到某新空间后再进行排序二分之类的操作 
