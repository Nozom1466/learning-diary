tricks: 

1. 一个频率一个栈，找最频繁的+最靠后的

[895](https://leetcode.cn/problems/maximum-frequency-stack/description/)
```python
class FreqStack:

    def __init__(self):
        self.num2freq = defaultdict(int)
        self.freq2ele = defaultdict(list)
        self.max_freq = 0

    def push(self, val: int) -> None: 
        self.num2freq[val] += 1
        self.max_freq = max(self.max_freq, self.num2freq[val])
        self.freq2ele[self.num2freq[val]].append(val)

    def pop(self) -> int:
        while len(self.freq2ele[self.max_freq]) == 0:
            self.max_freq -= 1
        ret = self.freq2ele[self.max_freq].pop()
        self.num2freq[ret] -= 1

        return ret

```

![895](https://pic.leetcode.cn/1669620804-VLSweF-895-7.png)


2. 消除

消除就是按照有效括号或者表达式解析来做就ok


3. 对顶栈

一个出栈一个入栈，注意数据结构的入栈出栈实现。

[2296](https://leetcode.cn/problems/design-a-text-editor/description/)
```python
class TextEditor:

    def __init__(self):
        self.stack_l = []
        self.stack_r = []
        self.PROB_NUM = 10

    def addText(self, text: str) -> None:
        for letter in text:
            self.stack_l.append(letter)

    def deleteText(self, k: int) -> int:
        mov = min(len(self.stack_l), k)
        for _ in range(mov):
            self.stack_l.pop()
        return mov

    def cursorLeft(self, k: int) -> str:
        mov = min(len(self.stack_l), k)
        for _ in range(mov):
            self.stack_r.append(self.stack_l.pop())
        return ''.join(self.stack_l[max(0, len(self.stack_l) - self.PROB_NUM):len(self.stack_l)])

    def cursorRight(self, k: int) -> str:
        mov = min(len(self.stack_r), k)
        for _ in range(mov):
            self.stack_l.append(self.stack_r.pop())
        return ''.join(self.stack_l[max(0, len(self.stack_l) - self.PROB_NUM):len(self.stack_l)])

```


4. 单调栈

找到第一个比自己大的数字在哪里，又或者第一个比自己小的数字在哪里。模板：

```python
def nearestGreater(nums: List[int]) -> Tuple[List[int], List[int]]:
    n = len(nums)
    # left[i] 是 nums[i] 左侧最近的严格大于 nums[i] 的数的下标，若不存在则为 -1
    left = [-1] * n
    st = []
    for i, x in enumerate(nums):
        while st and nums[st[-1]] <= x:  # 如果求严格小于，改成 >=
            st.pop()
        if st:
            left[i] = st[-1]
        st.append(i)

    # right[i] 是 nums[i] 右侧最近的严格大于 nums[i] 的数的下标，若不存在则为 n
    right = [n] * n
    st = []
    for i in range(n - 1, -1, -1):
        x = nums[i]
        while st and nums[st[-1]] <= x:
            st.pop()
        if st:
            right[i] = st[-1]
        st.append(i)

    return left, right
```


5. 单调栈矩形面积

左边第一个小的位置之后 to 右边第一个小的位置之前 (exclusive) 作为宽

[84](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)

```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left = [-1] * n
        st = []
        for i, h in enumerate(heights):
            while st and heights[st[-1]] >= h:
                st.pop()
            if st:
                left[i] = st[-1]
            st.append(i)

        right = [n] * n
        st.clear()
        for i in range(n - 1, -1, -1):
            h = heights[i]
            while st and heights[st[-1]] >= h:
                st.pop()
            if st:
                right[i] = st[-1]
            st.append(i)

        ans = 0
        for h, l, r in zip(heights, left, right):
            ans = max(ans, h * (r - l - 1))
        return ans
```


6. 贡献法

这个其实就是你在求了左边第一个小于，右边第一个小于之后，这中间的所有子数组对应的答案都指向当前这个数字，那就是这个数字相当于是这些数组的统一答案，也就是都有贡献度

[907](https://leetcode.cn/problems/sum-of-subarray-minimums/description/)

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        n = len(arr)
        stack = []
        left = [-1] * n
        for i, num in enumerate(arr):
            while stack and num <= arr[stack[-1]]:
                stack.pop()
            if stack:
                left[i] = stack[-1]
            stack.append(i)
        stack = []
        right = [n] * n
        for i in range(n - 1, -1, -1):
            while stack and arr[i] < arr[stack[-1]]:
                stack.pop()
            if stack:
                right[i] = stack[-1]
            stack.append(i)

        ans = 0
        for i, num in enumerate(arr):
            ans += num * (i - left[i]) * (right[i] - i)

        return int(ans % (10 ** 9 + 7))
```


7. 最小字典序

[402](https://leetcode.cn/problems/remove-k-digits/description/)

```python
class Solution:
    def removeKdigits(self, num: str, k: int) -> str:
        st = []
        rem = len(num) - k
        for i, d in enumerate(num):
            while k and st and st[-1] > d:
                st.pop()
                k -= 1
            st.append(d)
        return ''.join(st[:rem]).lstrip('0') or '0'
```