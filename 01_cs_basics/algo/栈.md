tricks: 

1. 一个频率一个栈，找最频繁的+最靠后的

[895](https://leetcode.cn/problems/maximum-frequency-stack/description/)
```python
class FreqStack:

    def __init__(self):
        self.num2freq = defaultdict(int)
        self.freq2ele = defaultdict(list)
        self.max_freq = 0

    def push(self, val: int) -> None: 
        self.num2freq[val] += 1
        self.max_freq = max(self.max_freq, self.num2freq[val])
        self.freq2ele[self.num2freq[val]].append(val)

    def pop(self) -> int:
        while len(self.freq2ele[self.max_freq]) == 0:
            self.max_freq -= 1
        ret = self.freq2ele[self.max_freq].pop()
        self.num2freq[ret] -= 1

        return ret

```

![895](https://pic.leetcode.cn/1669620804-VLSweF-895-7.png)


2. 消除

消除就是按照有效括号或者表达式解析来做就ok


3. 对顶栈

一个出栈一个入栈，注意数据结构的入栈出栈实现。

[2296](https://leetcode.cn/problems/design-a-text-editor/description/)
```python
class TextEditor:

    def __init__(self):
        self.stack_l = []
        self.stack_r = []
        self.PROB_NUM = 10

    def addText(self, text: str) -> None:
        for letter in text:
            self.stack_l.append(letter)

    def deleteText(self, k: int) -> int:
        mov = min(len(self.stack_l), k)
        for _ in range(mov):
            self.stack_l.pop()
        return mov

    def cursorLeft(self, k: int) -> str:
        mov = min(len(self.stack_l), k)
        for _ in range(mov):
            self.stack_r.append(self.stack_l.pop())
        return ''.join(self.stack_l[max(0, len(self.stack_l) - self.PROB_NUM):len(self.stack_l)])

    def cursorRight(self, k: int) -> str:
        mov = min(len(self.stack_r), k)
        for _ in range(mov):
            self.stack_l.append(self.stack_r.pop())
        return ''.join(self.stack_l[max(0, len(self.stack_l) - self.PROB_NUM):len(self.stack_l)])

```

